---
description: React/TypeScript component conventions for this project
globs: **/*.tsx
alwaysApply: false
---

# React Coding Standards

## Component Structure

Always use functional components with explicit `React.FC` typing:

```tsx
// ✅ GOOD
interface WorkItemCardProps {
  id: number;
  title: string;
  isDragging?: boolean;
}

export const WorkItemCard: React.FC<WorkItemCardProps> = ({ id, title, isDragging = false }) => {
  return <div>...</div>;
};

// ❌ BAD — class components, anonymous exports, missing types
export default function({ id }) { ... }
```

## Props Interfaces

- Name interfaces `ComponentNameProps`
- Define the interface directly above the component
- Optional props use `?`; set defaults in the destructuring signature

## Hooks Order

Inside every component, declare hooks in this order:

1. `useState`
2. `useRef`
3. `useQuery` / `useMutation` (TanStack Query)
4. `useMemo` / `useCallback`
5. `useEffect`
6. `useContext` / custom hooks

## Early Returns

Return `null` early for missing data or loading states — do not nest the entire render in a conditional:

```tsx
// ✅ GOOD
if (!workItem) return null;

// ❌ BAD
return workItem ? <div>...</div> : null;
```

## State Management

- **Local UI state**: `useState`
- **Server / async state**: TanStack Query (`useQuery`, `useMutation`, `useQueryClient`) — never fetch in `useEffect`
- **Shared cross-cutting state**: `useContext` with a dedicated context in `src/client/contexts/`
- No Redux or other global state libraries

## Forms

Use `react-hook-form` + `zod` for all forms with validation:

```tsx
const schema = z.object({ reason: z.string().min(1, 'Required') });
type FormValues = z.infer<typeof schema>;

const { register, handleSubmit, formState: { errors } } = useForm<FormValues>({
  resolver: zodResolver(schema),
  defaultValues: { reason: '' },
});
```

Never manage form field state manually with `useState`.

## Code Splitting

Lazy-load heavy view components from `App.tsx`:

```tsx
const ScrumCalendar = React.lazy(() => import('./components/ScrumCalendar'));

<Suspense fallback={<ViewSkeleton />}>
  <ErrorBoundary FallbackComponent={ViewErrorFallback}>
    <ScrumCalendar ... />
  </ErrorBoundary>
</Suspense>
```

Wrap every lazy view in both `Suspense` (loading) and `ErrorBoundary` (errors).

## Environment Variables

Access client-side `VITE_*` variables only through `src/client/config/env.ts` — never via `import.meta.env` directly in components or hooks. Add new variables to the Zod schema in that file.

## Code Organisation

- Reusable stateful logic → custom hook in `src/client/hooks/`
- API / data-fetching logic → TanStack Query inside custom hooks (not in services)
- Shared TypeScript types → `src/shared/types/` (re-exported from `src/client/types/` and `src/server/types/`)
- Client-only types → `src/client/types/`
